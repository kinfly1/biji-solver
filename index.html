<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ¯”é¸¡AIé…ç‰Œå™¨ (è’™ç‰¹å¡æ´›ç‰ˆ)</title>
    <style>
        :root { --primary: #1e3799; --accent: #38ada9; --danger: #e55039; --bg: #f1f2f6; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: var(--bg); margin: 0; padding: 10px; display: flex; flex-direction: column; align-items: center; }
        
        /* é¡¶éƒ¨æ§åˆ¶æ  */
        .header { text-align: center; margin-bottom: 15px; }
        h1 { margin: 5px 0; color: #0c2461; font-size: 1.5rem; }
        .config-area { display: flex; gap: 10px; justify-content: center; margin-top: 10px; background: white; padding: 10px; border-radius: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .config-btn { border: 1px solid #ccc; background: white; padding: 5px 15px; border-radius: 15px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
        .config-btn.active { background: var(--primary); color: white; border-color: var(--primary); font-weight: bold; }

        /* é€‰ç‰ŒåŒº */
        .selector { background: white; padding: 10px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); width: 100%; max-width: 500px; overflow-x: auto; }
        .suit-row { display: flex; gap: 4px; margin-bottom: 6px; justify-content: center; min-width: max-content; }
        .card-btn { 
            width: 32px; height: 46px; border: 1px solid #e1e1e1; border-radius: 4px; cursor: pointer; 
            font-weight: bold; font-size: 13px; display: flex; align-items: center; justify-content: center;
            background: #fff; position: relative;
        }
        .card-btn.red { color: #e55039; } .card-btn.black { color: #2f3542; }
        .card-btn.selected { background: var(--primary); color: white !important; border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        
        /* æ“ä½œåŒº */
        .controls { margin: 20px 0; display: flex; gap: 15px; width: 100%; max-width: 500px; }
        .action-btn { flex: 1; padding: 12px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .btn-calc { background: linear-gradient(135deg, #1e3799, #0c2461); }
        .btn-reset { background: linear-gradient(135deg, #e55039, #eb2f06); }

        /* ç»“æœå±•ç¤º */
        #results { width: 100%; max-width: 500px; }
        .solution { background: white; margin-bottom: 15px; border-radius: 10px; overflow: hidden; box-shadow: 0 3px 6px rgba(0,0,0,0.08); transition: transform 0.2s; }
        .solution-header { background: #f8f9fa; padding: 10px 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #eee; }
        .win-rate { font-size: 1.2em; font-weight: bold; color: var(--accent); }
        .win-rate small { font-size: 0.6em; color: #999; font-weight: normal; }
        .score-badge { background: #dfe6e9; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; color: #636e72; }
        
        .hand-row { display: flex; padding: 10px 15px; border-bottom: 1px dashed #f1f2f6; align-items: center; }
        .hand-label { width: 40px; font-weight: bold; color: #a4b0be; font-size: 0.9em; }
        .hand-cards { flex: 1; display: flex; gap: 5px; }
        .mini-card { padding: 2px 6px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.9em; background: #fff; min-width: 20px; text-align: center; }
        .hand-type { font-size: 0.85em; font-weight: bold; color: var(--primary); margin-left: 10px; }

        /* çŠ¶æ€ */
        #status { margin-bottom: 10px; color: #666; font-size: 0.9em; height: 20px; }
        .loader { display: inline-block; width: 12px; height: 12px; border: 2px solid #ccc; border-top-color: var(--primary); border-radius: 50%; animation: spin 1s infinite; margin-right: 5px; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="header">
        <h1>AI æ™ºèƒ½æ¯”é¸¡ (9å¼ )</h1>
        <div class="config-area">
            <span>ç©å®¶äººæ•°:</span>
            <button class="config-btn" onclick="setPlayers(2)">2äºº</button>
            <button class="config-btn active" onclick="setPlayers(3)">3äºº</button>
            <button class="config-btn" onclick="setPlayers(4)">4äºº</button>
            <button class="config-btn" onclick="setPlayers(5)">5äºº</button>
        </div>
    </div>

    <div class="selector" id="card-selector"></div>
    <div id="status">è¯·é€‰æ‹© 9 å¼ æ‰‹ç‰Œ</div>

    <div class="controls">
        <button class="action-btn btn-calc" onclick="runAI()">ğŸ¤– AI è®¡ç®—æœ€ä¼˜è§£</button>
        <button class="action-btn btn-reset" onclick="reset()">é‡ç½®</button>
    </div>

    <div id="results"></div>

<script>
    // --- é…ç½®ä¸å¸¸é‡ ---
    const SUITS = ['â™ ', 'â™¥', 'â™£', 'â™¦'];
    const RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    // æƒé‡: 2=0 ... A=12
    
    // ç‰Œå‹æƒé‡ (æ•°å€¼è¶Šå¤§è¶Šå¼º)
    const TYPE = {
        HIGH: 1, PAIR: 2, STRAIGHT: 3, FLUSH: 4, STRAIGHT_FLUSH: 5, BOMB: 6
    };
    
    let state = {
        selected: new Set(),
        players: 3, // é»˜è®¤3äººå±€
        simulations: 2000 // æ¨¡æ‹Ÿæ¬¡æ•°ï¼Œè¶Šå¤šè¶Šå‡†ä½†è¶Šæ…¢
    };

    // --- åˆå§‹åŒ–UI ---
    function init() {
        const container = document.getElementById('card-selector');
        SUITS.forEach((s, sIdx) => {
            const row = document.createElement('div');
            row.className = 'suit-row';
            RANKS.forEach((r, rIdx) => {
                const idx = sIdx * 13 + rIdx;
                const btn = document.createElement('div');
                btn.className = `card-btn ${sIdx % 2 === 1 ? 'red' : 'black'}`;
                btn.innerText = s + r;
                btn.id = `c-${idx}`;
                btn.onclick = () => toggleCard(idx);
                row.appendChild(btn);
            });
            container.appendChild(row);
        });
    }

    function toggleCard(idx) {
        const btn = document.getElementById(`c-${idx}`);
        if (state.selected.has(idx)) {
            state.selected.delete(idx);
            btn.classList.remove('selected');
        } else {
            if (state.selected.size >= 9) return;
            state.selected.add(idx);
            btn.classList.add('selected');
        }
        updateStatus();
    }

    function updateStatus() {
        document.getElementById('status').innerText = `å·²é€‰: ${state.selected.size}/9`;
    }

    function setPlayers(n) {
        state.players = n;
        document.querySelectorAll('.config-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');
    }

    function reset() {
        state.selected.clear();
        document.querySelectorAll('.card-btn').forEach(b => b.classList.remove('selected'));
        document.getElementById('results').innerHTML = '';
        updateStatus();
    }

    // --- æ ¸å¿ƒç®—æ³•å¼•æ“ ---

    // 1. åŸºç¡€ç‰Œå‹è¯„ä¼°
    function getHandRank(cards) {
        // cards: [{val:0-12, suit:0-3}, ...] sorted by val
        const v = cards.map(c => c.val);
        const s = cards.map(c => c.suit);
        
        const isFlush = s[0] === s[1] && s[1] === s[2];
        // é¡ºå­åˆ¤æ–­: A23 (12,0,1) ä¹Ÿæ˜¯é¡ºå­
        let isStraight = (v[2] === v[1]+1 && v[1] === v[0]+1);
        if (!isStraight && v[0]===0 && v[1]===1 && v[2]===12) isStraight = true; // A23

        // è±¹å­
        if (v[0] === v[1] && v[1] === v[2]) return { t: TYPE.BOMB, v: v[0], label: "è±¹å­" };
        // åŒèŠ±é¡º
        if (isFlush && isStraight) return { t: TYPE.STRAIGHT_FLUSH, v: v[2], label: "åŒèŠ±é¡º" };
        // åŒèŠ±
        if (isFlush) return { t: TYPE.FLUSH, v: v[2] + v[1]/100 + v[0]/10000, label: "åŒèŠ±" };
        // é¡ºå­
        if (isStraight) {
             // å¤„ç† A23ï¼Œæœ€å¤§ç‰Œæ˜¯ 3 (1)
             let top = (v[2]===12 && v[0]===0) ? v[1] : v[2];
             return { t: TYPE.STRAIGHT, v: top, label: "é¡ºå­" };
        }
        // å¯¹å­
        if (v[0]===v[1] || v[1]===v[2]) {
            let p = (v[0]===v[1]) ? v[0] : v[1];
            let k = (v[0]===v[1]) ? v[2] : v[0];
            return { t: TYPE.PAIR, v: p*100 + k, label: "å¯¹å­" };
        }
        // æ•£ç‰Œ
        return { t: TYPE.HIGH, v: v[2]*10000 + v[1]*100 + v[0], label: "æ•£ç‰Œ" };
    }

    function compareHands(h1, h2) {
        if (h1.t !== h2.t) return h1.t - h2.t;
        return h1.v - h2.v;
    }

    // 2. ç»„åˆç”Ÿæˆå™¨
    function getCombinations(arr, k) {
        let res = [];
        let f = (start, combo) => {
            if (combo.length === k) { res.push([...combo]); return; }
            for(let i=start; i<arr.length; i++) {
                combo.push(arr[i]); f(i+1, combo); combo.pop();
            }
        };
        f(0, []);
        return res;
    }

    // 3. AI æ¨¡æ‹Ÿæ ¸å¿ƒ
    async function runAI() {
        if (state.selected.size !== 9) return alert("å¿…é¡»é€‰æ»¡ 9 å¼ ç‰Œ");
        
        const statusDiv = document.getElementById('status');
        statusDiv.innerHTML = '<span class="loader"></span> AIæ­£åœ¨è¿›è¡Œè’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ...';
        
        // é¿å…å¡æ­»UI
        await new Promise(r => setTimeout(r, 50));

        const myCardsRaw = Array.from(state.selected);
        const myCards = myCardsRaw.map(i => ({ val: i%13, suit: Math.floor(i/13), id: i }));

        // è®¡ç®—å‰©ä½™ç‰Œå †
        let deck = [];
        for(let i=0; i<52; i++) {
            if (!state.selected.has(i)) deck.push(i);
        }

        // ç”Ÿæˆæ‰€æœ‰åˆæ³•çš„ 3-3-3 ç»„åˆ
        let validSplits = [];
        const heads = getCombinations(myCards, 3);
        
        for (let head of heads) {
            let rem1 = myCards.filter(c => !head.includes(c));
            let hRank = getHandRank(sortH(head));
            
            let mids = getCombinations(rem1, 3);
            for (let mid of mids) {
                let tail = rem1.filter(c => !mid.includes(c));
                let mRank = getHandRank(sortH(mid));
                
                // å€’æ°´æ£€æŸ¥: ä¸­å¿…é¡» >= å¤´
                if (compareHands(mRank, hRank) < 0) continue;

                let tRank = getHandRank(sortH(tail));
                // å€’æ°´æ£€æŸ¥: å°¾å¿…é¡» >= ä¸­
                if (compareHands(tRank, mRank) < 0) continue;

                validSplits.push({
                    head, mid, tail,
                    hRank, mRank, tRank,
                    wins: 0, score: 0
                });
            }
        }

        if (validSplits.length === 0) {
            statusDiv.innerHTML = "æ— è§£ï¼šæ‰€æœ‰ç»„åˆå‡å€’æ°´ (å»ºè®®æ£€æŸ¥è§„åˆ™æˆ–é‡æ–°å‘ç‰Œ)";
            return;
        }

        // è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿ
        // å¯¹æ¯ç§åˆæ³•æ‘†æ³•ï¼Œéšæœºç”Ÿæˆ N ç»„å¯¹æ‰‹ç‰Œè¿›è¡Œæ¯”å¯¹
        const SIM_COUNT = state.simulations; 
        const OPPONENTS = state.players - 1;

        for (let split of validSplits) {
            for (let i = 0; i < 200; i++) { // ä¸ºäº†æ€§èƒ½ï¼Œæ¯ä¸ªæ–¹æ¡ˆæ¨¡æ‹Ÿ200æ¬¡ï¼Œæ€»é‡å¯æ§
                // æ´—ç‰Œç”Ÿæˆå¯¹æ‰‹
                shuffle(deck);
                let currentDeckIdx = 0;
                
                let roundScore = 0; // æœ¬å±€å¾—åˆ†
                
                // æ¨¡æ‹Ÿå¤šä¸ªå¯¹æ‰‹
                for (let op = 0; op < OPPONENTS; op++) {
                    // å‘3å¼ ç»™å¯¹æ‰‹å¤´
                    let opH = [deck[currentDeckIdx++], deck[currentDeckIdx++], deck[currentDeckIdx++]];
                    // å‘3å¼ ç»™å¯¹æ‰‹ä¸­
                    let opM = [deck[currentDeckIdx++], deck[currentDeckIdx++], deck[currentDeckIdx++]];
                    // å‘3å¼ ç»™å¯¹æ‰‹å°¾
                    let opT = [deck[currentDeckIdx++], deck[currentDeckIdx++], deck[currentDeckIdx++]];

                    // ç®€å•è½¬æ¢æ ¼å¼
                    let opHR = getHandRank(sortRaw(opH));
                    let opMR = getHandRank(sortRaw(opM));
                    let opTR = getHandRank(sortRaw(opT));

                    // æ¯”è¾ƒ (èµ¢+1, è¾“-1, å¹³0)
                    // æ³¨æ„ï¼šè¿™é‡Œå‡è®¾å¯¹æ‰‹æ˜¯éšæœºæ‘†çš„ï¼Œå®é™…ä¸Šå¯¹æ‰‹ä¹Ÿä¼šç†ç‰Œã€‚
                    // ä¸ºäº†æ›´ç²¾å‡†ï¼Œæˆ‘ä»¬åº”è¯¥æŠŠå¯¹æ‰‹çš„9å¼ ç‰Œç†ä¸€éå–æœ€ä¼˜ã€‚
                    // *ä¼˜åŒ–*ï¼šå®Œå…¨æ¨¡æ‹Ÿå¯¹æ‰‹ç†ç‰Œå¤ªæ…¢ã€‚
                    // *æŠ˜ä¸­æ–¹æ¡ˆ*ï¼šå‡è®¾å¯¹æ‰‹ä¹Ÿä¼šæŠŠæœ€å¤§çš„æ”¾åé¢ã€‚
                    // æˆ‘ä»¬å°†å¯¹æ‰‹çš„9å¼ ç‰Œæ’åºï¼Œæœ€å¤§çš„3å¼ æ”¾å°¾ï¼Œä¸­é—´æ”¾ä¸­ï¼Œæœ€å°æ”¾å¤´ï¼ˆæ¨¡æ‹Ÿç†ç‰Œè¡Œä¸ºï¼‰ã€‚
                    let op9 = [...opH, ...opM, ...opT].map(idx => ({val: idx%13})).sort((a,b)=>a.val-b.val);
                    // è¿™ç§æ¨¡æ‹Ÿå¾ˆç²—ç³™ï¼Œä½†æ¯”çº¯éšæœºå¼ºã€‚æ›´å¼ºçš„æ¨¡æ‹Ÿéœ€è¦é€’å½’ï¼Œè¿™é‡Œçœç•¥ã€‚
                    
                    // ä¿®æ­£ï¼šä»…ä»…æ¯”å¤§å°ï¼Œä¸å‡è®¾å¯¹æ‰‹å®Œç¾ç†ç‰Œï¼Œé‡‡ç”¨æ¦‚ç‡ç¢°æ’ã€‚
                    // å®é™…ä¸Šï¼Œâ€œæ¯”é¸¡â€ä¸­ä¸»è¦çœ‹ä½ çš„ç‰Œåœ¨å‰©ä½™ç‰Œæ± ä¸­çš„æ’ä½ã€‚
                    
                    if (compareHands(split.hRank, opHR) > 0) roundScore++;
                    if (compareHands(split.mRank, opMR) > 0) roundScore++;
                    if (compareHands(split.tRank, opTR) > 0) roundScore++;
                }
                split.score += roundScore;
            }
        }

        // æ’åºï¼šåˆ†æ•°é«˜çš„åœ¨å‰
        validSplits.sort((a, b) => b.score - a.score);
        
        renderResults(validSplits.slice(0, 5), SIM_COUNT * OPPONENTS);
        statusDiv.innerText = "è®¡ç®—å®Œæˆ";
    }

    // --- è¾…åŠ©å‡½æ•° ---
    function sortH(cards) { return [...cards].sort((a,b)=>a.val - b.val); }
    function sortRaw(idxs) { 
        return idxs.map(i => ({val: i%13, suit: Math.floor(i/13)})).sort((a,b)=>a.val-b.val); 
    }
    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function renderResults(solutions, totalMatches) {
        const area = document.getElementById('results');
        area.innerHTML = '';

        solutions.forEach((sol, idx) => {
            // è®¡ç®—èƒœç‡ (å¾—åˆ† / (æ¨¡æ‹Ÿæ¬¡æ•° * 3é“)) - è¿‘ä¼¼å€¼
            // score æ˜¯å‡€èƒœåˆ†ï¼Œæˆ‘ä»¬è½¬æ¢æˆ "å¼ºåº¦æŒ‡æ•°"
            // æ˜¾ç¤ºå‰ï¼Œç¨å¾®ç¾åŒ–ä¸€ä¸‹ win rate
            
            const div = document.createElement('div');
            div.className = 'solution';
            
            let badge = idx === 0 ? "ğŸ† æœ€ä½³æ¨è" : `å¤‡é€‰æ–¹æ¡ˆ ${idx+1}`;
            let color = idx === 0 ? "#e55039" : "#666";

            div.innerHTML = `
                <div class="solution-header">
                    <span style="color:${color}; font-weight:bold">${badge}</span>
                    <span class="score-badge">ç»¼åˆè¯„åˆ†: ${sol.score}</span>
                </div>
                ${renderRow('å°¾å¢©', sol.tail, sol.tRank)}
                ${renderRow('ä¸­å¢©', sol.mid, sol.mRank)}
                ${renderRow('å¤´å¢©', sol.head, sol.hRank)}
            `;
            area.appendChild(div);
        });
    }

    function renderRow(label, cards, rank) {
        let html = cards.map(c => {
            let color = (c.suit === 1 || c.suit === 3) ? 'red' : 'black';
            return `<span class="mini-card" style="color:${color}">${SUITS[c.suit]}${RANKS[c.val]}</span>`;
        }).join('');
        
        return `
            <div class="hand-row">
                <span class="hand-label">${label}</span>
                <div class="hand-cards">${html}</div>
                <span class="hand-type">${rank.label}</span>
            </div>
        `;
    }

    init();
</script>
</body>
</html>